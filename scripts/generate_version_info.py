#!/usr/bin/env python3
"""Generate PyInstaller version_info metadata from pyproject.toml."""

from __future__ import annotations

import argparse
import re
from pathlib import Path

from versioning import load_project_metadata, resolve_current_version, resolve_next_version


def windows_version_tuple(version: str) -> tuple[int, int, int, int]:
    numbers = [int(value) for value in re.findall(r"\d+", version)]
    numbers = (numbers + [0, 0, 0, 0])[:4]
    return tuple(numbers)  # type: ignore[return-value]


def render_version_info(
    *,
    name: str,
    version: str,
    description: str,
    company_name: str,
    copyright_text: str,
) -> str:
    major, minor, patch, build = windows_version_tuple(version)
    version_tuple = f"({major}, {minor}, {patch}, {build})"
    exe_name = f"{name}.exe"
    safe_description = description.replace('"', '\\"')
    safe_name = name.replace('"', '\\"')
    safe_version = version.replace('"', '\\"')
    safe_company = company_name.replace('"', '\\"')
    safe_copyright = copyright_text.replace('"', '\\"')

    return f"""# UTF-8
#
# Generated by scripts/generate_version_info.py
VSVersionInfo(
  ffi=FixedFileInfo(
    filevers={version_tuple},
    prodvers={version_tuple},
    mask=0x3F,
    flags=0x0,
    OS=0x4,
    fileType=0x1,
    subtype=0x0,
    date=(0, 0)
  ),
  kids=[
    StringFileInfo(
      [
        StringTable(
          u'040904B0',
          [
            StringStruct(u'CompanyName',      u'{safe_company}'),
            StringStruct(u'FileDescription',  u'{safe_description}'),
            StringStruct(u'FileVersion',      u'{safe_version}'),
            StringStruct(u'InternalName',     u'{exe_name}'),
            StringStruct(u'OriginalFilename', u'{exe_name}'),
            StringStruct(u'ProductName',      u'{safe_name}'),
            StringStruct(u'ProductVersion',   u'{safe_version}'),
            StringStruct(u'LegalCopyright',   u'{safe_copyright}')
          ]
        )
      ]
    ),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)
"""


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate a PyInstaller version_info.txt file from pyproject metadata"
    )
    parser.add_argument(
        "--pyproject",
        default="pyproject.toml",
        help="Path to pyproject.toml",
    )
    parser.add_argument(
        "--output",
        default="build/version_info.txt",
        help="Output path for version info text file",
    )
    parser.add_argument(
        "--company-name",
        default="",
        help="Company name metadata for Windows file properties",
    )
    parser.add_argument(
        "--copyright",
        default="",
        help="Copyright metadata for Windows file properties",
    )
    parser.add_argument(
        "--version-mode",
        choices=["current", "next"],
        default="current",
        help="Version resolution mode when --version is not supplied",
    )
    parser.add_argument(
        "--version",
        default="",
        help="Optional explicit version override",
    )
    args = parser.parse_args()

    pyproject_path = Path(args.pyproject)
    project = load_project_metadata(pyproject_path)
    authors = project.get("authors", [])
    company_name = args.company_name
    if not company_name and isinstance(authors, list) and authors:
        first_author = authors[0]
        if isinstance(first_author, dict):
            company_name = str(first_author.get("name", ""))

    resolved_version = args.version.strip()
    if not resolved_version:
        resolved_version = (
            resolve_next_version(pyproject_path)
            if args.version_mode == "next"
            else resolve_current_version(pyproject_path)
        )

    content = render_version_info(
        name=str(project.get("name", "")),
        version=resolved_version,
        description=str(project.get("description", "")),
        company_name=company_name,
        copyright_text=args.copyright,
    )

    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content, encoding="utf-8")
    print(f"Generated {output_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
